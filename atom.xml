<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thor&#39;s Home</title>
  
  
  <link href="http://houchaoyue.top/atom.xml" rel="self"/>
  
  <link href="http://houchaoyue.top/"/>
  <updated>2022-10-11T07:40:25.251Z</updated>
  <id>http://houchaoyue.top/</id>
  
  <author>
    <name>HCY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>makefile学习</title>
    <link href="http://houchaoyue.top/2022/10/10/MakeFile%E5%AD%A6%E4%B9%A0/"/>
    <id>http://houchaoyue.top/2022/10/10/MakeFile%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-10-10T10:58:24.000Z</published>
    <updated>2022-10-11T07:40:25.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、gcc与g-的区别"><a href="#一、gcc与g-的区别" class="headerlink" title="一、gcc与g++的区别"></a>一、gcc与g++的区别</h3><h4 id="我们更习惯使用-gcc-指令编译-C-语言程序，用-g-指令编译-C-代码。需要强调的一点是，这并不是-gcc-和-g-的区别，gcc-指令也可以用来编译-C-程序，同样-g-指令也可以用于编译-C-语言程序。"><a href="#我们更习惯使用-gcc-指令编译-C-语言程序，用-g-指令编译-C-代码。需要强调的一点是，这并不是-gcc-和-g-的区别，gcc-指令也可以用来编译-C-程序，同样-g-指令也可以用于编译-C-语言程序。" class="headerlink" title="我们更习惯使用 gcc 指令编译 C 语言程序，用 g++ 指令编译 C++ 代码。需要强调的一点是，这并不是 gcc 和 g++ 的区别，gcc 指令也可以用来编译 C++ 程序，同样 g++ 指令也可以用于编译 C 语言程序。"></a>我们更习惯使用 gcc 指令编译 C 语言程序，用 g++ 指令编译 C++ 代码。需要强调的一点是，这并不是 gcc 和 g++ 的区别，gcc 指令也可以用来编译 C++ 程序，同样 g++ 指令也可以用于编译 C 语言程序。</h4><h6 id="1-实际上，只要是-GCC-支持编译的程序代码，都可以使用-gcc-命令完成编译。可以这样理解，gcc-是-GCC-编译器的通用编译指令，因为根据程序文件的后缀名，gcc-指令可以自行判断出当前程序所用编程语言的类别，比如："><a href="#1-实际上，只要是-GCC-支持编译的程序代码，都可以使用-gcc-命令完成编译。可以这样理解，gcc-是-GCC-编译器的通用编译指令，因为根据程序文件的后缀名，gcc-指令可以自行判断出当前程序所用编程语言的类别，比如：" class="headerlink" title="1.实际上，只要是 GCC 支持编译的程序代码，都可以使用 gcc 命令完成编译。可以这样理解，gcc 是 GCC 编译器的通用编译指令，因为根据程序文件的后缀名，gcc 指令可以自行判断出当前程序所用编程语言的类别，比如："></a>1.实际上，只要是 GCC 支持编译的程序代码，都可以使用 gcc 命令完成编译。可以这样理解，gcc 是 GCC 编译器的通用编译指令，因为根据程序文件的后缀名，gcc 指令可以自行判断出当前程序所用编程语言的类别，比如：</h6><ul><li><strong>xxx.c：默认以编译 C 语言程序的方式编译此文件；</strong></li><li><strong>xxx.cpp：默认以编译 C++ 程序的方式编译此文件。</strong></li><li><strong>xxx.m：默认以编译 Objective-C 程序的方式编译此文件；</strong></li><li><strong>xxx.go：默认以编译 Go 语言程序的方式编译此文件；</strong></li></ul><h6 id="2-但如果使用-g-指令，则无论目标文件的后缀名是什么，该指令都一律按照编译-C-代码的方式编译该文件。也就是说，对于-c-文件来说，gcc-指令以-C-语言代码对待，而-g-指令会以-C-代码对待。但对于-cpp-文件来说，gcc-和-g-都会以-C-代码的方式编译。"><a href="#2-但如果使用-g-指令，则无论目标文件的后缀名是什么，该指令都一律按照编译-C-代码的方式编译该文件。也就是说，对于-c-文件来说，gcc-指令以-C-语言代码对待，而-g-指令会以-C-代码对待。但对于-cpp-文件来说，gcc-和-g-都会以-C-代码的方式编译。" class="headerlink" title="2.但如果使用 g++ 指令，则无论目标文件的后缀名是什么，该指令都一律按照编译 C++ 代码的方式编译该文件。也就是说，对于 .c 文件来说，gcc 指令以 C 语言代码对待，而 g++ 指令会以 C++ 代码对待。但对于 .cpp 文件来说，gcc 和 g++ 都会以 C++ 代码的方式编译。"></a>2.但如果使用 g++ 指令，则无论目标文件的后缀名是什么，该指令都一律按照编译 C++ 代码的方式编译该文件。也就是说，对于 .c 文件来说，gcc 指令以 C 语言代码对待，而 g++ 指令会以 C++ 代码对待。但对于 .cpp 文件来说，gcc 和 g++ 都会以 C++ 代码的方式编译。</h6><h6 id="3-有读者可能会认为，C-兼容-C-语言，因此对于-C-语言程序来说，使用-gcc-编译还是使用-g-编译，应该没有什么区别，事实并非如此。严格来说，C-标准和-C-语言标准的语法要求是有区别的。举个例子："><a href="#3-有读者可能会认为，C-兼容-C-语言，因此对于-C-语言程序来说，使用-gcc-编译还是使用-g-编译，应该没有什么区别，事实并非如此。严格来说，C-标准和-C-语言标准的语法要求是有区别的。举个例子：" class="headerlink" title="3.有读者可能会认为，C++ 兼容 C 语言，因此对于 C 语言程序来说，使用 gcc 编译还是使用 g++ 编译，应该没有什么区别，事实并非如此。严格来说，C++ 标准和 C 语言标准的语法要求是有区别的。举个例子："></a>3.有读者可能会认为，C++ 兼容 C 语言，因此对于 C 语言程序来说，使用 gcc 编译还是使用 g++ 编译，应该没有什么区别，事实并非如此。严格来说，C++ 标准和 C 语言标准的语法要求是有区别的。举个例子：</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位于 demo.c 文件中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    printStr(a);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">printStr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如上所示，这是一段不规范的 C 语言代码。如果我们使用 gcc 指令编译，如下所示：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="params">#</span> gcc -xc demo.c   <span class="params">#</span>或者直接运行 gcc demo.c</span><br><span class="line">[root@bogon ~]<span class="params">#</span></span><br></pre></td></tr></table></figure><p><strong>可以看到，该指令的执行过程并没有发生任何错误。而同样的程序，如果我们使用 g++ 指令编译：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]# g++ demo.c</span><br><span class="line">demo.c: In function ‘int main()’:</span><br><span class="line">demo.c:5: error: ‘printStr’ was not declared in this scope</span><br><span class="line">demo.c:6: error: return-statement with no value, in function returning ‘int’</span><br><span class="line">[root@bogon ~]# </span><br></pre></td></tr></table></figure><p><strong>可以看到，GCC 编译器发现了 3 处错误。显然，C++ 标准对代码书写规范的要求更加严格。</strong></p><p><strong>除此之外对于编译执行 C++ 程序，使用 gcc 和 g++ 也是有区别的。要知道，很多 C++ 程序都会调用某些标准库中现有的函数或者类对象，而单纯的 gcc 命令是无法自动链接这些标准库文件的。举个例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str =<span class="string">&quot;C语言中文网&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这是一段很简单的 C++ 程序，其通过 <string> 头文件提供的 string 字符串类定义了一个字符串对象，随后使用 cout 输出流对象将其输出。对于这段 C++ 代码，如果我们使用 g++ 指令编译，如下所示：</string></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]# g++ demo.cpp</span><br><span class="line">[root@bogon ~]#</span><br></pre></td></tr></table></figure><p><strong>可以看到，整个编译过程没有报任何错误。但如果使用 gcc 指令：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]# gcc demo.cpp</span><br><span class="line">/tmp/ccIOnwra.o: In function `main&#x27;:</span><br><span class="line">demo.cpp:(.text+0x13): undefined reference to `std::allocator&lt;char&gt;::allocator()&#x27;</span><br><span class="line">\#省略了诸多错误信息</span><br></pre></td></tr></table></figure><p><strong>读者可自行编译，就可以看到很多报错信息。其根本原因就在于，该程序中使用了标准库 <iostream> 和<string> 提供的类对象，而 gcc 默认是无法找到它们的。</string></iostream></strong></p><p><strong>如果想使用 gcc 指令来编译执行 C++ 程序，需要在使用 gcc 指令时，手动为其添加 -lstdc++ -shared-libgcc 选项，表示 gcc 在编译 C++ 程序时可以链接必要的 C++ 标准库。也就是说，我们可以这样编译 demo.cpp 文件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]# gcc -xc++ demo.cpp -lstdc++ -shared-libgcc</span><br><span class="line">[root@bogon ~]#</span><br></pre></td></tr></table></figure><h3 id="二、GCC自动识别的文件扩展名（一览表）"><a href="#二、GCC自动识别的文件扩展名（一览表）" class="headerlink" title="二、GCC自动识别的文件扩展名（一览表）"></a>二、GCC自动识别的文件扩展名（一览表）</h3><table><thead><tr><th>文件名称+扩展名</th><th>GCC 编译器识别的文件类型</th></tr></thead><tbody><tr><td>file.c</td><td>尚未经过预处理操作的 C 源程序文件。</td></tr><tr><td>file.i</td><td>经过预处理操作、但尚未进行编译、汇编和连接的 C 源代码文件。</td></tr><tr><td>file.cpp file.cp file.cc file.cxx file.CPP file.c++ file.C</td><td>尚未经过预处理操作的 C++ 源代码文件。</td></tr><tr><td>file.ii</td><td>已经预处理操作，但尚未进行编译、汇编和连接的 C++ 源代码文件。</td></tr><tr><td>file.s</td><td>经过编译生成的汇编代码文件。</td></tr><tr><td>file.h</td><td>C、C++ 或者 Objective-C++ 语言头文件。</td></tr><tr><td>file.hh file.H file.hp file.hxx file.hpp file.HPP file.h++ file.tcc</td><td>C++ 头文件。</td></tr></tbody></table><p><img src="01.jpg"></p><h3 id="三、GCC编译C-x2F-C-程序"><a href="#三、GCC编译C-x2F-C-程序" class="headerlink" title="三、GCC编译C&#x2F;C++程序"></a>三、GCC编译C&#x2F;C++程序</h3><p><strong>C 或者 C++ 程序从源代码生成可执行程序的过程，需经历 4 个过程，分别是预处理、编译、汇编和链接。</strong></p><p><strong>1、.s结尾文件：</strong></p><p><strong>小写的 s文件，在后期阶段不会再进行预处理操作了，所以我们不能在其内写上预处理语句。</strong></p><p><strong>一般是 .c 文件经过汇编器处理后的输出。 如 GCC 编译器就可以指定 -S 选项进行输出，且是经过预处理器处理后的了。</strong></p><p><strong>2、.S结尾的文件：</strong></p><p><strong>大写的 S 文件，还会进行预处理、汇编等操作，所以我们可以在这里面加入预处理的命令。编译器在编译汇编大 S 文件之前会进行预处理操作。</strong></p><p><strong>3、.o文件</strong></p><p><strong>只编译不链接形成.o文件。里面包含了对各个函数的入口标记，描述，当程序要执行时还需要链接(link).链接就是把多个.o文件链成一个可执行文件。如 GCC 编译器就可以指定 -c选项进行输出。打开是乱码。</strong></p><h3 id="makefile的编写"><a href="#makefile的编写" class="headerlink" title="makefile的编写"></a>makefile的编写</h3><h4 id="1-单个文件的编译"><a href="#1-单个文件的编译" class="headerlink" title="1.单个文件的编译"></a>1.单个文件的编译</h4><h5 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Hello:Hello.o</span></span><br><span class="line">        g++ Hello.o -o Hello</span><br><span class="line"><span class="section">Hello.o:Hello.cpp</span></span><br><span class="line">        g++ -c Hello.cpp -o Hello.o</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Hello:Hello.o</span></span><br><span class="line">        g++ <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">Hello.o:Hello.cpp</span></span><br><span class="line">        g++ -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h4 id="2-多个文件的编译"><a href="#2-多个文件的编译" class="headerlink" title="2.多个文件的编译"></a>2.多个文件的编译</h4><h5 id="优化前-1"><a href="#优化前-1" class="headerlink" title="优化前"></a>优化前</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main:main.o student.o</span></span><br><span class="line">g++ main.o student.o -o main</span><br><span class="line"><span class="section">main.o:main.cpp</span></span><br><span class="line">g++ -c main.cpp -o main.o</span><br><span class="line"><span class="section">student.o:student.cpp</span></span><br><span class="line">g++ -c student.cpp -o student.o</span><br></pre></td></tr></table></figure><h5 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main:main.o student.o</span></span><br><span class="line">        g++ <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">%.o:%.cpp</span></span><br><span class="line">        g++ -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h4 id="3-跨文件夹的编译"><a href="#3-跨文件夹的编译" class="headerlink" title="3.跨文件夹的编译"></a>3.跨文件夹的编译</h4><h5 id="优化前-2"><a href="#优化前-2" class="headerlink" title="优化前"></a>优化前</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">bin/main:obj/main.o obj/student.o</span></span><br><span class="line">g++ obj/main.o obj/student.o -o bin/main</span><br><span class="line"><span class="section">obj/main.o:src/main.cpp</span></span><br><span class="line">g++ -c src/main.cpp -o obj/main.o</span><br><span class="line"><span class="section">obj/student.o:src/student.cpp</span></span><br><span class="line">g++ -I <span class="keyword">include</span>/ -c src/student.cpp -o obj/student.o</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="优化后-1"><a href="#优化后-1" class="headerlink" title="优化后"></a>优化后</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BIN=bin</span><br><span class="line">SRC=src</span><br><span class="line">INC=<span class="keyword">include</span></span><br><span class="line">OBJ=obj</span><br><span class="line"></span><br><span class="line">SRCS=<span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(SRC)</span>/*.cpp)</span></span><br><span class="line">OBJS=<span class="variable">$(<span class="built_in">patsubst</span> %.cpp,<span class="variable">$(OBJ)</span>/%.o,$(<span class="built_in">notdir</span> <span class="variable">$(SRCS)</span>)</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BIN)</span>/main:<span class="variable">$(OBJS)</span></span><br><span class="line">        g++ <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(OBJ)</span>/%.o:<span class="variable">$(SRC)</span>/%.cpp</span><br><span class="line">        g++ -I <span class="variable">$(INC)</span>/ -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h4 id="4-clean的编写"><a href="#4-clean的编写" class="headerlink" title="4.clean的编写"></a>4.clean的编写</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">rm bin/* obj/*</span><br></pre></td></tr></table></figure><p><strong>调用的时候使用make clean调用</strong></p><p><img src="02.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、gcc与g-的区别&quot;&gt;&lt;a href=&quot;#一、gcc与g-的区别&quot; class=&quot;headerlink&quot; title=&quot;一、gcc与g++的区别&quot;&gt;&lt;/a&gt;一、gcc与g++的区别&lt;/h3&gt;&lt;h4 id=&quot;我们更习惯使用-gcc-指令编译-C-语言程序，用-g</summary>
      
    
    
    
    <category term="工具学习" scheme="http://houchaoyue.top/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="http://houchaoyue.top/tags/Linux/"/>
    
    <category term="Makefile" scheme="http://houchaoyue.top/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>shell命令学习</title>
    <link href="http://houchaoyue.top/2022/10/10/shell%20%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <id>http://houchaoyue.top/2022/10/10/shell%20%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-10-10T10:58:24.000Z</published>
    <updated>2022-10-11T08:05:16.057Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、工具包之间传输中间结果的方法"><a href="#一、工具包之间传输中间结果的方法" class="headerlink" title="一、工具包之间传输中间结果的方法"></a>一、工具包之间传输中间结果的方法</h4><p>1.<strong>使用Pipe</strong></p><p><strong>Pipe（管道）</strong>，是 Unix&#x2F;Linux 系统中一种比较常用的 IPC(Inter Process Communication) 。</p><p>$ls$ 和 $wc$ 分别是两个独立的进程。shell 会将 ls 的输出结果作为 $wc$ 的输入结果，然后再由$wc$ 把处理结果投放到终端上。</p><p><img src="/./images/h8nlv3997i.png"></p><p>上图很生动地描绘出这组命令的工作流程。pipe 就像一根圆管，ls 的输出内容流入到圆管的一端 (标准输出)。随后，内容一直流到圆管的另一端 (标准输入) 由 wc 接收。这跟圆管只接受 byte stream，也就是说消息内容是无边界的。</p><p>2.<strong>用grep</strong></p><p>3.<strong>用redirect</strong></p><h4 id="二、命令行工具"><a href="#二、命令行工具" class="headerlink" title="二、命令行工具"></a>二、命令行工具</h4><p><strong>1.ag</strong></p><p><strong>2.ripgrep</strong></p><p><strong>3.awk</strong></p><p><strong>4.sed</strong></p><h4 id="三、shell（Bash）Batch-Script"><a href="#三、shell（Bash）Batch-Script" class="headerlink" title="三、shell（Bash）Batch Script"></a>三、shell（Bash）Batch Script</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、工具包之间传输中间结果的方法&quot;&gt;&lt;a href=&quot;#一、工具包之间传输中间结果的方法&quot; class=&quot;headerlink&quot; title=&quot;一、工具包之间传输中间结果的方法&quot;&gt;&lt;/a&gt;一、工具包之间传输中间结果的方法&lt;/h4&gt;&lt;p&gt;1.&lt;strong&gt;使用Pi</summary>
      
    
    
    
    <category term="工具学习" scheme="http://houchaoyue.top/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="http://houchaoyue.top/tags/Linux/"/>
    
    <category term="shell" scheme="http://houchaoyue.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>cmake学习</title>
    <link href="http://houchaoyue.top/2022/10/10/cmake%E5%AD%A6%E4%B9%A0/"/>
    <id>http://houchaoyue.top/2022/10/10/cmake%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-10-10T10:58:24.000Z</published>
    <updated>2022-10-11T07:30:04.253Z</updated>
    
    
    
    
    <category term="工具学习" scheme="http://houchaoyue.top/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="http://houchaoyue.top/tags/Linux/"/>
    
    <category term="cmake" scheme="http://houchaoyue.top/tags/cmake/"/>
    
  </entry>
  
</feed>
